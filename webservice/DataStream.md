# DataStream REST API


**DataStream**

A *DataStream* is a top level entity that is expected to be created by the 
user through UI. It can be thought of as a graph representing different 
components of an IoTaS topology and how they are connected. The components here
are the nodes of the graph and the connections between them are the edges. There
are three types of components. They are DataSources, DataSinks and Processors.
Each component within a DataStream is identified by a unique name in the UI. 
A DataStream entity has the following attributes.

Field| Type | Comment
---|---|----
dataStreamId | Long | The primary key
dataStreamName | String| Name given by the user from UI
json | String| String representation of json that depicts the graph
timestamp | Long | Time or creation or last update
 
**Components**

DataSource and DataSink components are something that user will already have 
added using UI. They are presumed to be present in the catalog. The Processor
component is what does processing on data flowing through topology. The most 
commonly used unit of a processor will be a rule, that will also come from 
the rule engine catalog. A processor can have more than one rule.


## Rest API

Due to the verbose nature of the json property a sample json can be referred 
to at http://www.jsoneditoronline.org/?id=1796339076a0854c7458726c07999911

Note that the json property is actually a string. Hence for a REST request to
the server it first needs to be JSON.stringify(json). 

### Create a DataStream 

`POST /api/v1/catalog/datastreams`

**Sample Input**

Please refer to the link for sample input and returned response. The request 
to create a new entity does not need id and timestamp fields. They will be 
generated by the server. On successful creation those two fields will be 
returned in the response json.
   
**Success Response**

    HTTP/1.1 201 Created
    Content-Type: application/json

### Get

`GET /api/v1/catalog/datastreams/1`

**Success Response**

    GET /api/v1/catalog/datastreams/1
    HTTP/1.1 200 OK
    Content-Type: application/json

Please refer to the link above for response json

**Error Response**

    GET /api/v1/catalog/datastreams/10
    HTTP/1.1 404 Not Found
    Content-Type: application/json
    
```json
{
  "responseCode": 1101,
  "responseMessage": "Entity with id [10] not found."
}
```

### Get All

`GET /api/v1/catalog/datastreams`

    GET /api/v1/catalog/datastreams
    HTTP/1.1 200 OK
    Content-Type: application/json


The response will have an array of jsons as per link above

### Update

`PUT /api/v1/catalog/datastreams/1`

*Sample Input*

Same as above with an updated value for dataStreamName and/or json fields

*Success Response*

    HTTP/1.1 200 OK
    Content-Type: application/json

Please refer to the link above for json response

### Delete

`DELETE /api/v1/catalog/datastreams/1`

*Success Response*

    HTTP/1.1 200 OK
    Content-Type: application/json

```json
{
  "responseCode": 1000,
  "responseMessage": "Success",
  "entity": {
  }
}
```

The entity property above will be the json response at the url


**More details on json property of DataStream**

Referring to the json at the link above, UI will be populating it based on 
information entered by user and retrieved from different components in IoTaS
catalog before submitting it through REST api. For dataSources/Sinks property 
within the json field, each dataSource needs to have a uiname attribute 
(preferably entered by the user). This should be unique across all components
for this data stream. All the other attributes should be populated by UI 
using the corresponding entity already added in the catalog. To be more 
elaborate, id field is the id of the entity in the catalog, type denotes the 
type for that entity. The config property for is expected to have different
properties in it based on the type.

For processors property in json, the most commonly used processor is 
anticipated to be rule. Although it may be extended to support other types as
well. The uiname identifies the processor uniquely within that data stream 
and the config property is expected to be an array of processor components. 
For now they will all be rules. Each rule object has the same structure and 
explanation as for dataSources and dataSinks described above.

The final section is links. This is what wires up the components described 
before. They can be thought of edges connecting those components. The key 
used for connecting components is the uiname. For now links are expected to 
go from a data source to a proessor/data sink or from a rule to a 
processor/data. Note that processor incoming edge is connected using uiname 
of the processor. However, the outgoing edges are connected using uiname of 
the rule. Processor can be thought of as a component with one input pin and 
multiple output pins. The validations will be done on the server side. 
However the UI should be able to create the json described from a visual 
graph so that it can be submitted via rest api and vice versa(i.e. produce a 
visual graph for a json retrieved from rest api)
